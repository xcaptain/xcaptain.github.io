{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/thread-and-lock","result":{"data":{"site":{"siteMetadata":{"author":{"name":"Joey Xie","contacts":{"twitter":"xf_joey"}},"disqusShortname":"joeyxf-com","subtitle":"每天进步一点点","title":"Joey的博客","url":"https://joeyxf.com"}},"markdownRemark":{"id":"c0898ace-3fbe-5a09-8ee1-eb34aa350483","html":"<p>本文将先介绍 Wait-free 和 Lock-free 算法，但是在有些场合必须要使用 lock，所以再讨论下各种语言标准库 lock 的实现，最后会探索下分布式锁的一些想法。</p>\n<p>首先要明确一点如果一个程序是单线程执行的，那肯定没有资源竞争(data race)，因为这个线程是顺序往前推进的，所谓的资源竞争只发生在多线程场景。所以像 redis 就没有数据竞争，因为只有一个线程在读写内存。</p>\n<h2 id=\"wait-free\" style=\"position:relative;\"><a href=\"#wait-free\" aria-label=\"wait free permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wait-free</h2>\n<p>那么在多线程场景如何处理资源竞争呢，首先介绍 Wait-free 算法，这个算法是一个很强的并发算法，就好比在一个十字路口每辆车都高速驶过，既不减速也不停下来等红绿灯但是决不会发生交通事故。听起来非常神奇，是怎么做到的呢，这里要引入原子操作(atomic)这一概念，如果多个线程对一个变量的访问是原子性的，那就可以不用加锁也不用等待一个线程访问结束，因为对这个变量的读写是用一条 CPU 指令来完成的，所以如果 2 个线程一读一写，到底是先读后写还是先写后读不重要，只要不会是这个变量读到一半，剩下一半被另一个线程改了就行。</p>\n<p>我们都直到变量是存在内存里的，但是 CPU 不是直接操作内存的而是直接操作寄存器，所以一个读的操作是先把值从内存读到寄存器，一个写操作是先把变量读到寄存器，修改寄存器里的值，再写入到内存，那么是不是 C/Rust 里的 primitive type 都是原子操作呢？这个得看情况，我用的是一个 x86-64 指令集的 CPU，并且用的是 64 位的操作系统，所以一次性最多能往寄存器里读一个 64 位的值，如 i64, u64 等所以对于简单类型是一次性就能读出来，但是对于 32 位的系统，要读一个 64 位的值要用到 2 个 32 位的寄存器，就涉及到 2 条指令，这时候就可能出现读第二条指令的时候，这部分被另一个写线程修改。</p>\n<p>那么不同语言对原子操作的实现如何呢？</p>\n<p>先看看 rust</p>\n<p>rust 对 atomic 的实现可以追溯到 <code class=\"language-text\">src/libcore/intrinsics.rs</code> 这个文件，这里面有很多 atomic 相关的 api 定义，但是没有实现，我们可以肯定这部分实现是依赖于 LLVM 的，而 LLVM 是用 C++写的，所以要得探索到 C++对原子操作的实现，这就太复杂了，贴两个相关链接<a href=\"http://llvm.org/docs/Atomics.html#atomic-orderings\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">llvm</a>, <a href=\"https://github.com/microsoft/STL/blob/a5a9e49fc6b87637e3c18ea23ac1c8cb176d80dd/stl/inc/atomic\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">c++ stl</a></p>\n<p>看看 Go 是怎么实现 atomic 的：</p>\n<p>主要的 api 接口定义在 <code class=\"language-text\">src/sync/atomic/doc.go</code>，但是具体的实现在 <code class=\"language-text\">src/runtime/internal/atomic</code>，而且在这个目录下分了不同 CPU 架构的实现，我的电脑是 64 位 intel 架构的，所以用的是 <code class=\"language-text\">atomic_amd64.go</code>下的实现，不过跟 rust 版本不太一样这里没有严格定义并发原子操作的内存访问顺序，在 rust 和 C++中是有</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">enum</span> Ordering <span class=\"token punctuation\">{</span>\n    Relaxed<span class=\"token punctuation\">,</span>\n    Release<span class=\"token punctuation\">,</span>\n    Acquire<span class=\"token punctuation\">,</span>\n    AcqRel<span class=\"token punctuation\">,</span>\n    SeqCst<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>的，不过在 go 中有 <code class=\"language-text\">LoadAcq</code> 这个方法，意思应该就是以 <code class=\"language-text\">Acquire</code> 的顺序来访问这块内存吧，其他更复杂的顺序没在代码中看到。</p>\n<p>总结一下，要实现 wait-free 算法必须要保证对共享变量的访问是原子的，但是标准库中只能保证一些很简单的类型的原子访问。</p>\n<h2 id=\"lock-free\" style=\"position:relative;\"><a href=\"#lock-free\" aria-label=\"lock free permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Lock-free</h2>\n<p>Lock-free 是比 wait-free 更弱一点的算法，意思就是当线程 A 在访问一块内存时，线程 B 在一边等待，等线程 A 操作结束后 B 再操作。听起来似乎是要加锁实现，也就是说 A 访问时设置锁，B 访问时检测到锁就进入等待状态，A 完成之后释放锁，这时候 B 开始进行访问。但是咱们现在讨论的是 Lock-free 算法啊，如果有锁的话和 free 这个名字冲突了，那到底是怎么实现的呢？</p>\n<p>以下图为例，本来队列中有 1、2 这 2 个元素了，这时候 2 个线程分别要写入 3、4 到这个队列中，很可能 3、4 都会被添加到 2 后面，这样就冲突了，期望的答案应该是 2 后面跟 3,3 后面跟 4,那么要如何做呢？</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">  1           1\n  |           |\n  2     -&gt;    2\n / \\          |\n3   4         3\n              |\n              4</code></pre></div>\n<p>为什么会出现第一种分叉的情况呢，就是因为把一个元素拼接到队列中要 2 步操作，第一步是让 3 指向 2,第二步是把队列的队尾指针指向 3,在第一步的时候很可能 3、4 都指向 2 了。要避免这种情况就得把这两步合并为一步来做，这时候又要用到一个原子操作的原语<code class=\"language-text\">atomic_compare_exchange</code>，以这个图为例，先通过<code class=\"language-text\">atomic_compare_exchange</code>检测到 2 和 3 不相等，那么就执行把 3 拼到 2 后面的操作，这时候另一个线程想把 4 拼到队尾，他通过循环执行<code class=\"language-text\">atomic_compare_exchange</code>检测到队尾的值现在是 3,和自身不相等，就把 4 拼到 3 后面</p>\n<p>这个 atomic<em>compare</em>exchange 也就是鼎鼎大名的<code class=\"language-text\">CAS</code> compare and swap。rust中默认就用的C++的这个<code class=\"language-text\">atomic_compare_exchange</code>，但是Go的代码不太一样，具体还是在 <code class=\"language-text\">src/sync/atomic/doc.go</code>，但是方法命令类似 <code class=\"language-text\">CompareAndSwapInt32</code>，具体的实现可以追溯到<code class=\"language-text\">src/runtime/internal/atomic</code>这个目录下的<code class=\"language-text\">atomic_amd64.go</code>中的<code class=\"language-text\">Cas64</code>之类的方法，不过这个go文件只包含方法定义，具体的实现在一个汇编文件中，叫<code class=\"language-text\">asm_amd64.s</code>，具体可以贴一段代码看看</p>\n<div class=\"gatsby-highlight\" data-language=\"nasm\"><pre class=\"language-nasm\"><code class=\"language-nasm\"><span class=\"token operator\">/</span><span class=\"token operator\">/</span> bool Cas(int32 <span class=\"token operator\">*</span>val, int32 old, int32 new)\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span> Atomically:\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\tif(<span class=\"token operator\">*</span>val <span class=\"token operator\">=</span><span class=\"token operator\">=</span> old){\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\t<span class=\"token operator\">*</span>val <span class=\"token operator\">=</span> new<span class=\"token comment\">;</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\treturn <span class=\"token number\">1</span><span class=\"token comment\">;</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t} else\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\treturn <span class=\"token number\">0</span><span class=\"token comment\">;</span>\nTEXT runtime∕internal∕atomic·Cas(SB),NOSPLIT,<span class=\"token number\">$0</span><span class=\"token operator\">-</span><span class=\"token number\">17</span>\n\tMOVQ\tptr<span class=\"token operator\">+</span><span class=\"token number\">0</span>(FP), <span class=\"token register variable\">BX</span>\n\tMOVL\told<span class=\"token operator\">+</span><span class=\"token number\">8</span>(FP), <span class=\"token register variable\">AX</span>\n\tMOVL\tnew<span class=\"token operator\">+</span><span class=\"token number\">12</span>(FP), <span class=\"token register variable\">CX</span>\n\tLOCK\n\tCMPXCHGL\t<span class=\"token register variable\">CX</span>, <span class=\"token number\">0</span>(<span class=\"token register variable\">BX</span>)\n\tSETEQ\tret<span class=\"token operator\">+</span><span class=\"token number\">16</span>(FP)\n\tRET\n\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span> bool\truntime∕internal∕atomic·Cas64(uint64 <span class=\"token operator\">*</span>val, uint64 old, uint64 new)\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span> Atomically:\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\tif(<span class=\"token operator\">*</span>val <span class=\"token operator\">=</span><span class=\"token operator\">=</span> <span class=\"token operator\">*</span>old){\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\t<span class=\"token operator\">*</span>val <span class=\"token operator\">=</span> new<span class=\"token comment\">;</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\treturn <span class=\"token number\">1</span><span class=\"token comment\">;</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t} else {\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t\treturn <span class=\"token number\">0</span><span class=\"token comment\">;</span>\n<span class=\"token operator\">/</span><span class=\"token operator\">/</span>\t}\nTEXT runtime∕internal∕atomic·Cas64(SB), NOSPLIT, <span class=\"token number\">$0</span><span class=\"token operator\">-</span><span class=\"token number\">25</span>\n\tMOVQ\tptr<span class=\"token operator\">+</span><span class=\"token number\">0</span>(FP), <span class=\"token register variable\">BX</span>\n\tMOVQ\told<span class=\"token operator\">+</span><span class=\"token number\">8</span>(FP), <span class=\"token register variable\">AX</span>\n\tMOVQ\tnew<span class=\"token operator\">+</span><span class=\"token number\">16</span>(FP), <span class=\"token register variable\">CX</span>\n\tLOCK\n\tCMPXCHGQ\t<span class=\"token register variable\">CX</span>, <span class=\"token number\">0</span>(<span class=\"token register variable\">BX</span>)\n\tSETEQ\tret<span class=\"token operator\">+</span><span class=\"token number\">24</span>(FP)\n\tRET</code></pre></div>\n<p>我是看不懂这段代码，汇编里咋还跑出了<code class=\"language-text\">LOCK</code>这个指令了，难道说所谓的Lock-free算法没有在内存设锁但是在CPU上有锁？费解</p>\n<h2 id=\"锁\" style=\"position:relative;\"><a href=\"#%E9%94%81\" aria-label=\"锁 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>锁</h2>\n<p>说到锁就简单了，这是最low的一种方法，性能肯定比前2种差很多，但是用起来最简单，大家都知道锁分为2类，读写锁和互斥锁，也就是<code class=\"language-text\">RwLock</code>和<code class=\"language-text\">Mutex</code>，但是很奇怪为啥Go要把读写锁命名为<code class=\"language-text\">RwMutex</code>，rust和C++都是叫<code class=\"language-text\">RwLock</code>。接下来比较下具体的实现</p>\n<p>Rust在锁定一个变量时会调用操作系统的api，也就是<code class=\"language-text\">pthread_mutex_lock</code>，这个方法是阻塞的，也就是说会阻塞这个线程直到获得锁，下面那个<code class=\"language-text\">try_lock</code>方法就是非阻塞的，如果当前没法获得锁就返回false有调用方决定怎么办。还有一个有意思的地方在于用户不需要手动调用<code class=\"language-text\">unlock</code>的方法来释放锁，因为rust会自动在这个锁后面的变量结束生命周期的时候释放，对用户来说又省事多了</p>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">pub</span> <span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">fn</span> <span class=\"token function\">lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> r <span class=\"token operator\">=</span> libc<span class=\"token punctuation\">::</span><span class=\"token function\">pthread_mutex_lock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>inner<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">debug_assert_eq!</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">pub</span> <span class=\"token keyword\">unsafe</span> <span class=\"token keyword\">fn</span> <span class=\"token function\">try_lock</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">-></span> bool <span class=\"token punctuation\">{</span>\n    libc<span class=\"token punctuation\">::</span><span class=\"token function\">pthread_mutex_trylock</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span>inner<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>看看Go的实现吧</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token punctuation\">(</span>m <span class=\"token operator\">*</span>Mutex<span class=\"token punctuation\">)</span> <span class=\"token function\">Lock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// Fast path: grab unlocked mutex.</span>\n\t<span class=\"token keyword\">if</span> atomic<span class=\"token punctuation\">.</span><span class=\"token function\">CompareAndSwapInt32</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&amp;</span>m<span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> mutexLocked<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> race<span class=\"token punctuation\">.</span>Enabled <span class=\"token punctuation\">{</span>\n\t\t\trace<span class=\"token punctuation\">.</span><span class=\"token function\">Acquire</span><span class=\"token punctuation\">(</span>unsafe<span class=\"token punctuation\">.</span><span class=\"token function\">Pointer</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">return</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token comment\">// Slow path (outlined so that the fast path can be inlined)</span>\n\tm<span class=\"token punctuation\">.</span><span class=\"token function\">lockSlow</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>又见熟悉的cas了，也就是说go没有用操作系统提供的api而是自己实现了一套，第一个判断走cas，意思是如果没有锁竞争那么直接标记为locked然后返回，如果有锁竞争呢就走下面那个<code class=\"language-text\">lockSlow</code>的方法，这个方法就复杂了，核心也是cas而且有for循环等待，有点像spinlock，但是做了很多优化</p>\n<h2 id=\"总结\" style=\"position:relative;\"><a href=\"#%E6%80%BB%E7%BB%93\" aria-label=\"总结 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>总结</h2>\n<p>原子操作和锁在rust和go都是在sync这个模块下，意思就是用来做多线程同步的，不过相比来说rust依赖系统调用而go是完全自己实现了一套锁，哪个实现好不好判断，因为个人喜欢rust所以觉得操作系统能解决的事情就让操作系统来做的理念更好，著名的rust开发者matklad曾经有过2篇博客比较系统自带的mutex和自己实现的spinlock哪个好，文章见下：</p>\n<ul>\n<li><a href=\"https://matklad.github.io/2020/01/02/spinlocks-considered-harmful.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Spinlocks Considered Harmful</a></li>\n<li><a href=\"https://matklad.github.io/2020/01/04/mutexes-are-faster-than-spinlocks.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Mutexes Are Faster Than Spinlocks</a></li>\n</ul>\n<p>按他的意思是利用了系统调用的mutex比用户态自己实现的spinlock好，所以无脑一下rust的锁比Go的高明吧！</p>","fields":{"slug":"/posts/thread-and-lock","tagSlugs":["/tag/programming/"]},"frontmatter":{"date":"2020-05-02 20:51","description":"在并发的场景中我们经常要用到锁来避免资源竞争，不同的语言有不同的实现，比如说rust是调用操作系统的接口，Go是自己实现了一套用户态的锁，至于java就更多了","tags":["Programming"],"title":"不同语言锁的实现"}}},"pageContext":{"slug":"/posts/thread-and-lock"}}}